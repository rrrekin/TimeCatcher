name: Manual Release

on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: Tag to create (defaults to v<package.json version>)
        required: false
        type: string
      release_name:
        description: Release name (defaults to TimeCatcher <version>)
        required: false
        type: string
      draft:
        description: Create release as draft (default false)
        type: boolean
        default: false
        required: true
      prerelease:
        description: Mark as prerelease
        type: boolean
        default: false
        required: true

permissions:
  contents: write

concurrency:
  group: manual-release-${{ github.ref || github.workflow }}
  cancel-in-progress: true

env:
  NODE_VERSION: '24'
  # Prevent accidental code signing / notarization in CI
  CSC_IDENTITY_AUTO_DISCOVERY: 'false'
  ELECTRON_SKIP_NOTARIZATION: 'true'

jobs:
  check:
    name: Check Release
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.version.outputs.tag }}
      name: ${{ steps.version.outputs.name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Resolve version/tag
        id: version
        shell: bash
        run: |
          set -euo pipefail
          PKG_VERSION=$(node -p "require('./package.json').version")
          INPUT_TAG="${{ github.event.inputs.release_tag }}"
          # Validate provided tag (must look like v<semver>)
          if [ -n "${INPUT_TAG}" ]; then
            if [[ "${INPUT_TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+([-.][0-9A-Za-z.+-]+)?$ ]]; then
              TAG="${INPUT_TAG}"
            else
              echo "Error: Invalid tag format: '${INPUT_TAG}'. Expected 'v<major>.<minor>.<patch>' optionally with pre-release/build metadata." >&2
              exit 1
            fi
          else
            TAG="v${PKG_VERSION}"
          fi
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"

          # Resolve release name: explicit input > derived from tag > from package.json
          INPUT_NAME="${{ github.event.inputs.release_name }}"
          if [ -n "${INPUT_NAME}" ]; then
            NAME="${INPUT_NAME}"
          else
            if [ -n "${INPUT_TAG}" ]; then
              VERSION_FROM_TAG="${TAG#v}"
              NAME="TimeCatcher ${VERSION_FROM_TAG}"
            else
              NAME="TimeCatcher ${PKG_VERSION}"
            fi
          fi
          echo "name=${NAME}" >> "$GITHUB_OUTPUT"

      - name: Check if release exists (fail if it does)
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.version.outputs.tag }}"
          CANONICAL_URL="${GITHUB_SERVER_URL%/}/$GITHUB_REPOSITORY/releases/tag/$TAG"

          if gh -R "$GITHUB_REPOSITORY" release view "$TAG" --json url > /dev/null 2>&1; then
            echo "::error::Release $TAG already exists at: $CANONICAL_URL"
            echo "::error::Cannot create a release that already exists. Please use a different tag or delete the existing release first."
            exit 1
          else
            echo "Release $TAG does not exist. Proceeding with release creation..."
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build:
    name: Build - ${{ matrix.platform }}
    runs-on: ${{ matrix.os }}
    needs: check
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            platform: macos
            build_cmd: npm run build:mac
          - os: windows-latest
            platform: windows
            build_cmd: npm run build:win
          - os: ubuntu-latest
            platform: linux
            build_cmd: npm run build:linux

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
      - name: Install dependencies
        run: npm ci
      - name: Build (${{ matrix.platform }})
        run: ${{ matrix.build_cmd }}
      - name: Upload artifacts (${{ matrix.platform }})
        uses: actions/upload-artifact@v4
        with:
          name: timecatcher-${{ matrix.platform }}
          path: |
            dist/packages/**
          if-no-files-found: error

  release:
    name: Create Release
    needs: [check, build]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Determine previous tag
        id: prev
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            let prevTag = null;
            try {
              const latest = await github.rest.repos.getLatestRelease({owner, repo});
              prevTag = latest.data.tag_name;
            } catch (e) {
              core.info('No published releases found, falling back to latest tag');
              try {
                const tags = await github.rest.repos.listTags({owner, repo, per_page: 1});
                if (tags.data.length > 0) {
                  prevTag = tags.data[0].name;
                }
              } catch (e2) {
                core.info('No tags found either.');
              }
            }
            core.setOutput('tag', prevTag || '');

      - name: Generate changelog
        id: changelog
        shell: bash
        run: |
          set -euo pipefail

          PREV="${{ steps.prev.outputs.tag }}"
          if [ -n "$PREV" ]; then
            echo "Generating changelog from $PREV to HEAD"
            RANGE="$PREV..HEAD"
          else
            echo "Generating changelog from repository start to HEAD"
            RANGE="$(git rev-list --max-parents=0 HEAD)..HEAD"
          fi

          # Debug: Show what we're working with
          echo "DEBUG: RANGE=$RANGE"
          echo "DEBUG: Checking git repository status..."
          git status --porcelain || echo "DEBUG: git status failed"
          echo "DEBUG: Current HEAD:"
          git log --oneline -5 || echo "DEBUG: git log failed"

          # Initialize changelog with header
          echo "DEBUG: Creating CHANGELOG.md..."
          echo "# What's Changed" > CHANGELOG.md
          echo >> CHANGELOG.md
          echo "DEBUG: CHANGELOG.md created successfully"

          # Function to clean commit message (remove type prefix)
          echo "DEBUG: Defining clean_commit_message function..."
          clean_commit_message() {
            local msg="$1"
            echo "DEBUG: Cleaning message: '$msg'" >&2
            # Remove conventional commit prefix and format as bullet point
            # Use parameter expansion instead of sed to avoid issues
            if [[ "$msg" == *": "* ]]; then
              result="- ${msg#*: }"
            else
              result="- $msg"
            fi
            echo "DEBUG: Cleaned to: '$result'" >&2
            echo "$result"
          }
          echo "DEBUG: clean_commit_message function defined"

          # Function to get commits by type and format them
          echo "DEBUG: Defining get_commits_by_type function..."
          get_commits_by_type() {
            local pattern="$1"
            local section_title="$2"
            local emoji="$3"
            echo "DEBUG: get_commits_by_type called with pattern='$pattern', title='$section_title', emoji='$emoji'"

            echo "DEBUG: Running git log with pattern '$pattern'..."
            COMMITS=$(git log --no-merges \
              --grep="$pattern" \
              --pretty=format:'%s' \
              "$RANGE") || true
            echo "DEBUG: git log completed, exit code: $?"

            if [ -n "$COMMITS" ]; then
              echo "DEBUG: Found commits for $pattern:"
              echo "$COMMITS" | while read -r line; do echo "DEBUG:   '$line'"; done
              echo "DEBUG: Adding section: $emoji $section_title"
              echo "## $emoji $section_title" >> CHANGELOG.md
              echo >> CHANGELOG.md
              echo "DEBUG: Processing each commit..."
              while IFS= read -r commit; do
                echo "DEBUG: Processing commit: '$commit'"
                clean_commit_message "$commit" >> CHANGELOG.md
              done <<< "$COMMITS"
              echo >> CHANGELOG.md
              echo "DEBUG: Section completed successfully"
              return 0
            else
              echo "DEBUG: No commits found for pattern '$pattern'"
              return 1
            fi
          }
          echo "DEBUG: get_commits_by_type function defined"

          # Check for breaking changes first (highest priority)
          echo "DEBUG: Checking for breaking changes..."
          BREAKING=$(git log --no-merges \
            --grep="!" \
            --pretty=format:'%s' \
            "$RANGE") || true
          echo "DEBUG: Breaking changes search completed, exit code: $?"

          # Filter for actual breaking changes (those with ! in the type)
          if [ -n "$BREAKING" ]; then
            echo "DEBUG: Found potential breaking changes:"
            echo "$BREAKING" | while read -r line; do echo "DEBUG:   '$line'"; done
            echo "DEBUG: Filtering for actual breaking changes..."
            BREAKING=$(echo "$BREAKING" | grep "!:" || true)
            echo "DEBUG: Filtered breaking changes:"
            echo "$BREAKING" | while read -r line; do echo "DEBUG:   '$line'"; done
          else
            echo "DEBUG: No potential breaking changes found"
          fi

          echo "DEBUG: Checking for BREAKING CHANGE footer..."
          BREAKING_FOOTER=$(git log --no-merges \
            --grep="BREAKING CHANGE" \
            --pretty=format:'%s' \
            "$RANGE") || true
          echo "DEBUG: BREAKING CHANGE footer search completed, exit code: $?"

          if [ -n "$BREAKING" ] || [ -n "$BREAKING_FOOTER" ]; then
            echo "DEBUG: Adding BREAKING CHANGES section"
            echo "## ðŸ’¥ BREAKING CHANGES" >> CHANGELOG.md
            echo >> CHANGELOG.md
            if [ -n "$BREAKING" ]; then
              echo "DEBUG: Processing breaking changes with ! syntax..."
              while IFS= read -r commit; do
                echo "DEBUG: Processing breaking commit: '$commit'"
                clean_commit_message "$commit" >> CHANGELOG.md
              done <<< "$BREAKING"
            fi
            if [ -n "$BREAKING_FOOTER" ]; then
              echo "DEBUG: Processing breaking changes with footer syntax..."
              while IFS= read -r commit; do
                echo "DEBUG: Processing breaking footer commit: '$commit'"
                clean_commit_message "$commit" >> CHANGELOG.md
              done <<< "$BREAKING_FOOTER"
            fi
            echo >> CHANGELOG.md
            echo "DEBUG: BREAKING CHANGES section completed"
          else
            echo "DEBUG: No breaking changes found"
          fi

          # Generate sections for different commit types
          echo "DEBUG: Starting commit type processing..."
          get_commits_by_type "^feat" "Features" "ðŸš€" || true
          echo "DEBUG: feat processing completed with exit code: $?"

          get_commits_by_type "^fix" "Bug Fixes" "ðŸ›" || true
          echo "DEBUG: fix processing completed with exit code: $?"

          get_commits_by_type "^perf" "Performance Improvements" "âš¡" || true
          echo "DEBUG: perf processing completed with exit code: $?"

          get_commits_by_type "^docs" "Documentation" "ðŸ“š" || true
          echo "DEBUG: docs processing completed with exit code: $?"

          get_commits_by_type "^style" "Code Style" "ðŸŽ¨" || true
          echo "DEBUG: style processing completed with exit code: $?"

          get_commits_by_type "^refactor" "Refactoring" "â™»ï¸" || true
          echo "DEBUG: refactor processing completed with exit code: $?"

          get_commits_by_type "^test" "Testing" "âœ…" || true
          echo "DEBUG: test processing completed with exit code: $?"

          get_commits_by_type "^build" "Build System" "ðŸ—ï¸" || true
          echo "DEBUG: build processing completed with exit code: $?"

          get_commits_by_type "^ci" "CI/CD" "âš™ï¸" || true
          echo "DEBUG: ci processing completed with exit code: $?"

          get_commits_by_type "^chore" "Other Changes" "ðŸ”§" || true
          echo "DEBUG: chore processing completed with exit code: $?"

          # If no categorized commits found, add fallback
          echo "DEBUG: Checking if any sections were added..."
          if ! grep -q "^## " CHANGELOG.md; then
            echo "DEBUG: No sections found, adding fallback"
            echo "## ðŸ”§ Changes" >> CHANGELOG.md
            echo >> CHANGELOG.md
            echo "- Various improvements and fixes" >> CHANGELOG.md
            echo >> CHANGELOG.md
          else
            echo "DEBUG: Sections were found in changelog"
          fi

          echo "DEBUG: Changelog generation completed"
          echo "DEBUG: Final CHANGELOG.md content:"
          cat CHANGELOG.md

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: release_artifacts
          merge-multiple: true

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.check.outputs.tag }}
          name: ${{ needs.check.outputs.name }}
          draft: ${{ fromJson(github.event.inputs.draft) }}
          prerelease: ${{ fromJson(github.event.inputs.prerelease) }}
          body_path: CHANGELOG.md
          files: |
            release_artifacts/**/TimeCatcher-*.dmg
            release_artifacts/**/TimeCatcher-*.exe
            release_artifacts/**/TimeCatcher-*.AppImage
            release_artifacts/**/TimeCatcher-*.snap
            release_artifacts/**/TimeCatcher-*.blockmap
            release_artifacts/**/TimeCatcher-*.zip
            release_artifacts/**/latest*.yml
            release_artifacts/**/app-update.yml
            release_artifacts/**/*.zsync
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
