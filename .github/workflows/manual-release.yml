name: Manual Release

on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: Tag to create (defaults to v<package.json version>)
        required: false
        type: string
      release_name:
        description: Release name (defaults to TimeCatcher <version>)
        required: false
        type: string
      draft:
        description: Create release as draft (default false)
        type: boolean
        default: false
        required: true
      prerelease:
        description: Mark as prerelease
        type: boolean
        default: false
        required: true

permissions:
  contents: write

concurrency:
  group: manual-release-${{ github.ref || github.workflow }}
  cancel-in-progress: true

env:
  NODE_VERSION: '24'
  # Prevent accidental code signing / notarization in CI
  CSC_IDENTITY_AUTO_DISCOVERY: 'false'
  ELECTRON_SKIP_NOTARIZATION: 'true'

jobs:
  build:
    name: Build - ${{ matrix.platform }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            platform: macos
            build_cmd: npm run build:mac
          - os: windows-latest
            platform: windows
            build_cmd: npm run build:win
          - os: ubuntu-latest
            platform: linux
            build_cmd: npm run build:linux

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
      - name: Install dependencies
        run: npm ci
      - name: Build (${{ matrix.platform }})
        run: ${{ matrix.build_cmd }}
      - name: Upload artifacts (${{ matrix.platform }})
        uses: actions/upload-artifact@v4
        with:
          name: timecatcher-${{ matrix.platform }}
          path: |
            dist/packages/**
          if-no-files-found: error

  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Resolve version/tag
        id: version
        shell: bash
        run: |
          set -euo pipefail
          PKG_VERSION=$(node -p "require('./package.json').version")
          INPUT_TAG="${{ github.event.inputs.release_tag }}"
          # Validate provided tag (must look like v<semver>)
          if [ -n "${INPUT_TAG}" ]; then
            if [[ "${INPUT_TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+([-.][0-9A-Za-z.+-]+)?$ ]]; then
              TAG="${INPUT_TAG}"
            else
              echo "Error: Invalid tag format: '${INPUT_TAG}'. Expected 'v<major>.<minor>.<patch>' optionally with pre-release/build metadata." >&2
              exit 1
            fi
          else
            TAG="v${PKG_VERSION}"
          fi
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"

          # Resolve release name: explicit input > derived from tag > from package.json
          INPUT_NAME="${{ github.event.inputs.release_name }}"
          if [ -n "${INPUT_NAME}" ]; then
            NAME="${INPUT_NAME}"
          else
            if [ -n "${INPUT_TAG}" ]; then
              VERSION_FROM_TAG="${TAG#v}"
              NAME="TimeCatcher ${VERSION_FROM_TAG}"
            else
              NAME="TimeCatcher ${PKG_VERSION}"
            fi
          fi
          echo "name=${NAME}" >> "$GITHUB_OUTPUT"

      - name: Determine previous tag
        id: prev
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            let prevTag = null;
            try {
              const latest = await github.rest.repos.getLatestRelease({owner, repo});
              prevTag = latest.data.tag_name;
            } catch (e) {
              core.info('No published releases found, falling back to latest tag');
              try {
                const tags = await github.rest.repos.listTags({owner, repo, per_page: 1});
                if (tags.data.length > 0) {
                  prevTag = tags.data[0].name;
                }
              } catch (e2) {
                core.info('No tags found either.');
              }
            }
            core.setOutput('tag', prevTag || '');

      - name: Generate changelog
        id: changelog
        shell: bash
        run: |
          PREV="${{ steps.prev.outputs.tag }}"
          if [ -n "$PREV" ]; then
            echo "Generating changelog from $PREV to HEAD"
            RANGE="$PREV..HEAD"
          else
            echo "Generating changelog from repository start to HEAD"
            RANGE="$(git rev-list --max-parents=0 HEAD)..HEAD"
          fi
          {
            echo "## Changes"
            echo
            git log --no-merges --pretty=format:'- %s (%h) by %an' $RANGE
            echo
          } > CHANGELOG.md

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: release_artifacts
          merge-multiple: true

      - name: Check if release exists
        id: release_exists
        shell: bash
        run: |
          set -euo pipefail

          # Ensure GITHUB_TOKEN is set before using gh
          if [ -z "${GITHUB_TOKEN:-}" ]; then
            echo "::error::GITHUB_TOKEN is not set. Please ensure the workflow has access to secrets.GITHUB_TOKEN." >&2
            exit 1
          fi
          export GH_TOKEN="${GITHUB_TOKEN}"

          TAG="${{ steps.version.outputs.tag }}"

          # Create temp files first and ensure cleanup on any exit
          TEMP_STDOUT=$(mktemp)
          TEMP_STDERR=$(mktemp)
          trap 'rm -f "$TEMP_STDOUT" "$TEMP_STDERR"' EXIT

          # Pin the repository and request both htmlUrl and url, preferring htmlUrl when present (fallback if htmlUrl unsupported)
          if gh -R "$GITHUB_REPOSITORY" release view "$TAG" --json htmlUrl,url --jq '.htmlUrl // .url' > "$TEMP_STDOUT" 2> "$TEMP_STDERR"; then
            # Success: release exists
            RELEASE_URL=$(printf "%s" "$(cat "$TEMP_STDOUT")")
            echo "Release $TAG already exists at: $RELEASE_URL"
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "release_url=$RELEASE_URL" >> "$GITHUB_OUTPUT"
          else
            # First failure: check if it's due to an unknown 'htmlUrl' field (older gh CLI); if so, retry with only 'url'
            STDERR_CONTENT=$(cat "$TEMP_STDERR")
            if echo "$STDERR_CONTENT" | grep -Eiq '(Unknown JSON field|unknown field).*htmlUrl'; then
              if gh -R "$GITHUB_REPOSITORY" release view "$TAG" --json url --jq '.url' > "$TEMP_STDOUT" 2> "$TEMP_STDERR"; then
                RELEASE_URL=$(printf "%s" "$(cat "$TEMP_STDOUT")")
                echo "Release $TAG already exists at: $RELEASE_URL"
                echo "exists=true" >> "$GITHUB_OUTPUT"
                echo "release_url=$RELEASE_URL" >> "$GITHUB_OUTPUT"
              else
                # Retry failed: evaluate not-found patterns or fail fast
                STDERR_CONTENT=$(cat "$TEMP_STDERR")
                if echo "$STDERR_CONTENT" | grep -Eiq "(Could not resolve to a Release with the tag name|release not found|could not find release|HTTP 404)"; then
                  echo "Release $TAG does not exist"
                  echo "exists=false" >> "$GITHUB_OUTPUT"
                  echo "release_url=" >> "$GITHUB_OUTPUT"
                else
                  echo "::error::Failed to check release status for $TAG: $STDERR_CONTENT"
                  exit 1
                fi
              fi
            else
              # Not an 'htmlUrl' field issue: check prioritized not-found messages across different gh versions
              if echo "$STDERR_CONTENT" | grep -Eiq "(Could not resolve to a Release with the tag name|release not found|could not find release|HTTP 404)"; then
                echo "Release $TAG does not exist"
                echo "exists=false" >> "$GITHUB_OUTPUT"
                echo "release_url=" >> "$GITHUB_OUTPUT"
              else
                # Other error - fail fast
                echo "::error::Failed to check release status for $TAG: $STDERR_CONTENT"
                exit 1
              fi
            fi
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub Release
        if: ${{ !fromJSON(steps.release_exists.outputs.exists) }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: ${{ steps.version.outputs.name }}
          draft: ${{ github.event.inputs.draft == 'true' }}
          prerelease: ${{ github.event.inputs.prerelease == 'true' }}
          body_path: CHANGELOG.md
          files: |
            release_artifacts/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release already exists
        id: existing_release
        if: ${{ fromJSON(steps.release_exists.outputs.exists) }}
        run: |
          echo "::warning::Release ${{ steps.version.outputs.tag }} already exists. Skipping release creation."
          echo "Existing release URL: ${{ steps.release_exists.outputs.release_url }}"
          echo "release_url=${{ steps.release_exists.outputs.release_url }}" >> "$GITHUB_OUTPUT"
          echo "Release [${{ steps.version.outputs.name }}](${{ steps.release_exists.outputs.release_url }}) already exists: ${{ steps.release_exists.outputs.release_url }}" >> "$GITHUB_STEP_SUMMARY"
